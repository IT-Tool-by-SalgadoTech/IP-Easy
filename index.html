<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Salgado Technologies — IP-Easy</title>

<!-- Leaflet (map) -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<style>
  :root{--bg:#0b0b0f;--fg:#eaf2ff;--muted:#9fb3c9;--card:#12141c;--line:#1f2637;--accent:#3aa0ff;--ok:#60d394;--warn:#ffd166}
  *{box-sizing:border-box;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  body{margin:0;background:#0b0b0f;color:var(--fg)}
  header{display:flex;gap:14px;align-items:center;justify-content:space-between;padding:18px;border-bottom:1px solid var(--line);background:#0e111a}
  header img{height:130px;width:auto;border-radius:12px;background:#000}
  h1{margin:0;font-size:26px}
  .sub{color:var(--muted)}
  main{padding:18px;max-width:1240px;margin:auto}
  .card{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:14px}
  label{display:block;margin:8px 0 6px;color:#cfe0f8;font-weight:600}
  input,button{width:100%;padding:12px;border-radius:12px;border:1px solid var(--line);background:#0f1422;color:var(--fg)}
  button{cursor:pointer;background:var(--accent);color:#001129;font-weight:700;border:none}
  .row{display:grid;grid-template-columns:1fr 180px 180px;gap:10px}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:14px}
  .out{background:#0f1422;border:1px solid var(--line);border-radius:12px;padding:12px}
  table{width:100%;border-collapse:collapse}
  th,td{border-bottom:1px solid var(--line);padding:8px 6px;text-align:left;vertical-align:middle}
  th{color:#cfe0f8}
  .pill{display:inline-block;padding:3px 8px;border-radius:999px;background:#142745;border:1px solid #21406b;color:#9ed1ff;font-size:12px}
  .pill.blue{background:#163a5c;border-color:#2d6aa0;color:#9ed1ff}
  .pill.gray{background:#2b2f3a;border-color:#3e4556;color:#d7deea}
  small{color:var(--muted)}
  .toolbar{display:flex;gap:10px;flex-wrap:wrap;margin:10px 0}
  .mini{padding:6px 10px;border-radius:10px;font-size:13px}
  .copy{background:#1b2a44;color:#cde2ff;border:1px solid #2a4270}
  tr.recommended{outline:2px solid var(--ok);outline-offset:-2px;background:#0f1a12}
  .hero{flex:1;display:flex;justify-content:flex-end;align-items:center}
  .heroTitle{font-size:clamp(40px,8vw,120px);font-weight:900;letter-spacing:.5px;color:#ffffff;opacity:1;white-space:nowrap;margin-right:8px}

  .twoCol{display:grid;grid-template-columns:1fr 1fr;gap:14px}
  textarea{width:100%;min-height:130px;resize:vertical;padding:12px;border-radius:12px;border:1px solid var(--line);background:#0f1422;color:#var(--fg)}
  select{width:100%;padding:12px;border-radius:12px;border:1px solid var(--line);background:#0f1422;color:#var(--fg)}
  .note{background:#101b2b;border:1px dashed #28456e;color:#cde2ff;padding:10px;border-radius:10px;margin-top:10px}
  .hints{display:flex;flex-direction:column;gap:8px;margin-top:10px}
  .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}
  .muted{color:var(--muted)}
  .right{display:flex;justify-content:flex-end}
  /* VLSM toggle alignment */
  .vlsm-toggles{margin-top:12px;display:grid;row-gap:12px}
  .vlsm-toggles .row{display:grid;grid-template-columns:auto 1fr auto;align-items:center;column-gap:10px}
  .vlsm-toggles .row select{max-width:140px}

  /* Map container height */
  #geoMap{height:220px;border-radius:12px;overflow:hidden}

  /* === Topology Builder (merged) === */
  #topoBuilder{margin-top:16px}
  #topoToolbar{display:flex;gap:8px;flex-wrap:wrap;margin:10px 0}
  #topoToolbar .mini{padding:8px 12px;border-radius:10px}
  #palette{display:flex;gap:8px;flex-wrap:wrap}
  .paletteBtn{background:#1b2a44;color:#cde2ff;border:1px solid #2a4270;padding:8px 10px;border-radius:10px;cursor:pointer}
  #topoCanvas{position:relative;min-height:360px;background:#0f1422;border:1px dashed #334;border-radius:12px;margin-top:10px;user-select:none;overflow:hidden}
  .node{position:absolute;left:12px;top:12px;padding:8px 10px;border-radius:10px;border:1px solid #2a4270;background:#142745;color:#cde2ff;cursor:grab;display:flex;gap:6px;align-items:center}
  .node:active{cursor:grabbing}
  .node .dot{width:8px;height:8px;border-radius:999px;background:#60d394}
  .node.mdm .dot{background:#ffd166}   /* Modem */
  .node.swi .dot{background:#9ed1ff}   /* Switch */
  .node.pc  .dot{background:#60d394}   /* PC */
  .node.rtr .dot{background:#ff8a5b}   /* Router */
  .node .tag{font-weight:700;opacity:.95}
  .node .kill{
    margin-left:8px;border:none;background:#2b364f;color:#cfe0f8;
    border-radius:8px;padding:0 6px;font-weight:900;cursor:pointer;line-height:18px
  }
  .node .kill:hover{background:#394767}
  #assignWrap{margin-top:12px}
  #assignTbl th, #assignTbl td{white-space:nowrap}

  /* LAN blocks */
  #lanBlocks{display:flex;flex-direction:column;gap:8px}
  .lanCard{background:#0f1422;border:1px solid var(--line);border-radius:10px;padding:8px;display:grid;grid-template-columns:1fr 36px;gap:8px;align-items:center}
  /* number field removed */
  .lanDel{background:#22304a;border:0;color:#cfe0f8;border-radius:8px;cursor:pointer}

  /* === SAFE ADDITIONS === */
  #topoBuilder{grid-column:1 / -1; width:100%;}
  #topoCanvas{width:100%; min-height:720px;}
  .node .officeSel{min-width:220px;max-width:240px;padding:4px 6px;font-size:12px;border-radius:8px;border:1px solid #2a4270;background:#0f1422;color:#cde2ff;margin-left:6px}
select, input[type='number'] { color: #ffffff !important; }

  /* === Patch: make per-device "X" button clearly clickable (UI only) === */
  .node{position:absolute; padding-right:26px}
  .node .kill{
    position:absolute; top:4px; right:4px; z-index:3;
    min-width:22px; height:22px; display:inline-flex; align-items:center; justify-content:center;
  }


/* === UI Simplification Patch: hide Topology placement UI (keep logic intact) === */
#topoToolbar, #topoCanvas, #topology, .topology, [data-section="topology"] { display: none !important; }


/* === UI Simplification Patch: per-office device controls === */
.lanCard{display:flex;flex-direction:column;gap:6px;position:relative}
.lanHead{display:flex;align-items:center;gap:8px}
.lanHead .lanName{flex:1}
.lanHead .lanBtns{display:flex;gap:6px}
.lanHead .lanDel{min-width:28px;height:28px}


/* === Patch: compact horizontal device buttons inside each Office === */
.lanDevices{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
.lanDevices .mini{width:auto;display:inline-flex;align-items:center;justify-content:center;padding:6px 12px}


/* Stack the VLSM inputs under LAN blocks without moving DOM */
.twoCol{grid-template-columns:1fr !important}
</style>

<!-- PDF libs -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>


<style>
#p2pLinks {
  width: 100px;  /* Increase width to ensure the number is visible */
}
</style>

<style>#clearVlsm{display:none !important}</style>
<style>
/* === IP‑Easy Manual Modal ============================================ */
#manualBackdrop{position:fixed;inset:0;background:rgba(3,7,18,.7);backdrop-filter:saturate(120%) blur(2px);display:none;z-index:9998}
#manualModal{position:fixed;inset:auto;left:50%;top:50%;transform:translate(-50%,-50%);max-width:960px;max-height:78vh;background:var(--card);border:1px solid var(--line);border-radius:16px;overflow:auto;display:none;z-index:9999;box-shadow:0 20px 60px rgba(0,0,0,.55);resize:both;min-width:360px;min-height:260px}
#manualHeader{display:flex;align-items:center;justify-content:space-between;padding:14px 16px;border-bottom:1px solid var(--line);background:#0e111a;cursor:move;-webkit-user-select:none;-ms-user-select:none;user-select:none}
#manualHeader h3{margin:0;font-size:18px;color:#eaf2ff}
#manualClose{appearance:none;border:0;background:#22304a;color:#cfe0f8;border-radius:10px;padding:6px 10px;cursor:pointer;font-weight:700}
#manualClose:hover{background:#2b3a5a}
#manualBody{padding:14px 16px 6px 16px;overflow:visible;max-height:none}
#manualBody h4{margin:.7em 0 .35em 0}
#manualBody p{margin:.3em 0 .6em 0;color:var(--fg)}
#manualBody code{background:#0f1422;border:1px solid var(--line);padding:0 6px;border-radius:6px}
#manualBody .pill{margin-left:6px}
#manualBody ul{margin:.2em 0 .6em 1.2em}
#manualBody li{margin:.25em 0}
#manualBody .grid2{display:grid;grid-template-columns:1fr 1fr;gap:12px}
#manualBody .cardx{background:#0f1422;border:1px solid var(--line);border-radius:12px;padding:12px}
#manualFooter{display:flex;justify-content:flex-end;gap:8px;padding:10px 16px 14px 16px;border-top:1px solid var(--line);background:#0e111a}
#manualFooter .mini{padding:8px 12px;border-radius:10px}
@media (max-width: 860px){
  #manualBody .grid2{grid-template-columns:1fr}
}
</style>

<style>
/* === P2P /31 Help Modal ============================================ */
#p2pHelpBackdrop{
  position:fixed;
  inset:0;
  background:rgba(3,7,18,.7);
  backdrop-filter:saturate(120%) blur(2px);
  display:none;
  z-index:9980;
}
#p2pHelpModal{
  position:fixed;
  left:50%;
  top:50%;
  transform:translate(-50%,-50%);
  max-width:860px;
  max-height:78vh;
  background:var(--card);
  border:1px solid var(--line);
  border-radius:16px;
  overflow:auto;
  display:none;
  z-index:9981;
  box-shadow:0 20px 60px rgba(0,0,0,.55);
}
#p2pHelpHeader{
  display:flex;
  align-items:center;
  justify-content:space-between;
  padding:12px 16px;
  border-bottom:1px solid var(--line);
  background:#0e111a;
}
#p2pHelpHeader h3{
  margin:0;
  font-size:18px;
  color:#eaf2ff;
}
#p2pHelpClose{
  appearance:none;
  border:0;
  background:#22304a;
  color:#cfe0f8;
  border-radius:10px;
  padding:6px 10px;
  cursor:pointer;
  font-weight:700;
}
#p2pHelpClose:hover{background:#2b3a5a}
#p2pHelpBody{
  padding:14px 16px 10px 16px;
  font-size:14px;
}
#p2pHelpBody table{
  width:100%;
  border-collapse:collapse;
  margin:8px 0 10px 0;
}
#p2pHelpBody th,
#p2pHelpBody td{
  border-bottom:1px solid var(--line);
  padding:6px 4px;
  text-align:left;
  vertical-align:middle;
}
#p2pHelpBody th{
  color:#cfe0f8;
}
#p2pHelpBody code{
  background:#0f1422;
  border:1px solid var(--line);
  padding:0 6px;
  border-radius:6px;
}
#p2pHelpBody ul{
  margin:.2em 0 .6em 1.2em;
}
#p2pHelpBody li{
  margin:.25em 0;
}
</style>

</head>
<body>
  <header>
    <img id="logo" alt="Salgado Technologies logo" src="LOGO VIDEO black.png" onerror="this.style.display='none'"/>
    <div>
      <h1>Salgado Technologies</h1>
      <div class="sub">Network Planning Toolkit</div>
    </div>
    <div class="hero"><span class="heroTitle">IP-Easy</span></div>
  </header>

  <main>
<section id="myIpCard" class="card" style="margin-top:16px">
      <div style="margin:0 0 8px"><h2 style="margin:0">My Public IP Information</h2></div>
      <div class="grid">
        <div id="geoInfo" class="out" style="min-height:150px">
          <div>Detecting your public IP…</div>
        </div>
        <div id="geoMap"></div>
      </div>
    </section>
<div class="card" style="margin-bottom:16px">
      <label for="ip">IPv4 address (only)</label>
      <div class="row">
        <input id="ip" placeholder="e.g., 10.0.0.137" />
        <button id="howManual" title="Read the user guide">How IP‑Easy Works</button>
        <button id="go">Analyze</button>
      </div>

<!-- Public IP info (moved to top, auto-load) -->
    


      <small>Enter an IP and press <b>Analyze</b>. Optionally add <b>Devices needed</b> to auto-highlight the smallest subnet that fits and suggest a gateway.</small>
    </div>

    

    <div class="grid">
      <section class="card">
        <h2 style="margin:0 0 8px">IP Summary</h2>
        <div id="quick" class="out">Waiting for input…</div>
        <div class="toolbar">
          <button id="copyBin" class="mini copy" title="Copy binary address">Copy Binary</button>
          <button id="printPage" class="mini">Print</button>
          <button id="exportPdf" class="mini">Export PDF</button>
        </div>
      </section>
      <section class="card">
        <h2 style="margin:0 0 8px">Binary (8 bits per octet)</h2>
        <div id="bin" class="out">—</div>
        <div class="note" style="margin-top:10px">
          <b>IPv4 Class Reference</b><br/>
          <b>Class A:</b> 0–127 → /8 255.0.0.0<br/>
          <b>Class B:</b> 128–191 → /16 255.255.0.0<br/>
          <b>Class C:</b> 192–223 → /24 255.255.255.0<br/>
          <b>Class D:</b> 224–239 → Multicast<br/>
          <b>Class E:</b> 240–255 → Reserved
        </div>
      </section>
    </div>

    

    <section class="card" style="margin-top:16px">
      <h2 style="margin:0 0 8px">Quick Subnet Picks (by host capacity)</h2>
      <small>We compute network details from your IP for common masks. Each row includes wildcard and a Copy button.</small>
      <div class="note" style="margin:8px 0">
        <b>Legend:</b> <span class="pill blue">P2P Link (RFC 3021)</span> — use <span class="mono">/31</span> for router-to-router links.
        <span class="pill gray">Single Host</span> — use <span class="mono">/32</span> for loopbacks or single-host addresses.
      </div>
      <div class="out" style="margin-top:10px">
        <div style="overflow:auto">
          <table id="tbl">
            <thead>
              <tr>
                <th>Usable Hosts</th>
                <th>Prefix Size</th>
                <th>Mask</th>
                <th>Wildcard</th>
                <th>Block Size</th>
                <th>Network</th>
                <th>First</th>
                <th>Last</th>
                <th>Broadcast</th>
                <th></th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
      <small id="gwHint" style="display:block;margin-top:8px"></small>
    </section>
  
    <section class="card" style="margin-top:16px">
      <h2 style="margin:0 0 8px">Subnet Designer — Variable Length Subnet Masking (VLSM) + Topology</h2>
      <small>Enter <b>PC counts per subnet</b> (not including the gateway). We’ll add the gateway automatically, apply optional growth margin, and fit subnets inside a base block.</small>

      
<div class="twoCol" style="margin-top:10px">
  <div>
    <label>Offices / LAN blocks</label>
    <div id="lanBlocks"></div>
    <div class="toolbar" style="margin-top:6px">
      <button id="addLan" class="mini">+ Add LAN</button>
      <button id="clearLan" class="mini">Clear LANs</button>
    </div>
    <small class="muted">Define your LANs here. We'll add the gateway automatically if enabled and apply growth margin.</small>
  </div>
  <div>

        <div>
          <label for="vlsmBase">Base block</label>
          <select id="vlsmBase">
            <option value="auto" selected>Auto (by class)</option>
            <option value="24">/24</option>
            <option value="23">/23</option>
            <option value="22">/22</option>
            <option value="21">/21</option>
            <option value="20">/20</option>
          </select>

          <div class="vlsm-toggles">
  <label class="row" for="p2pLinks">
    <span>Router-to-Router links (<span class="mono">/31</span>)</span>
    <input id="p2pLinks" type="number" min="0" step="1" value="0" style="max-width:120px"/>
    <span>
      <button type="button" id="p2pHelpBtn" class="mini" style="width:auto">P2P-Router_Help</button>
    </span>
  </label>
            <label class="row" for="addGw">
              <input id="addGw" type="checkbox" checked />
              <span>Add 1 for gateway (recommended)</span>
              <span></span>
            </label>
            <label class="row" for="addMargin">
              <input id="addMargin" type="checkbox" checked />
              <span>Add growth margin</span>
              <select id="marginPct">
                <option value="10">+10%</option>
                <option value="20" selected>+20%</option>
                <option value="30">+30%</option>
                <option value="50">+50%</option>
              </select>
            </label>
          </div>

          <div class="toolbar" style="margin-top:10px">
            <button id="runVlsm">Run VLSM</button>
            <button id="clearVlsm" class="mini">Clear</button>
          </div>

          <div id="comcastNote" class="note" style="display:none">
            <b>Comcast/Xfinity:</b> Common gateways default to <span class="mono">.1</span> on LAN and may ship with LAN <span class="mono">10.0.0.0/24</span>.
          </div>
        </div>
      </div>

      <div class="out" style="margin-top:12px">
        <div style="overflow:auto">
          <table id="vlsmTbl">
            <thead>
              <tr>
                <th>Office</th>
                <th>Need</th>
                <th>Prefix Size</th>
                <th>Mask</th>
                <th>Wildcard</th>
                <th>Network</th>
                <th>Gateway</th>
                <th>First</th>
                <th>Last</th>
                <th>Broadcast</th>
                <th>DHCP Pool</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>

      <div class="note"><b>Tip – recommended margins:</b> Home/Micro: 0–10%. Small business: 20–30%. Guests/fast growth: 50–100%.</div>
      <div class="hints">
        <div id="super23" class="muted"></div>
        <div id="super22" class="muted"></div>
      </div>

      <!-- Topology Builder -->
      <div id="topoBuilder" class="out">
        <h3 style="margin:0 0 8px">Topology Builder</h3>
        <small>Add devices and drag them on the canvas. When you click <b>Run VLSM</b>, subnets and IPs are auto-assigned to devices (heuristic).</small>
        <div id="topoToolbar">
          <div id="palette">
            <button type="button" class="paletteBtn" data-type="mdm">+ Modem</button>
            <button type="button" class="paletteBtn" data-type="rtr">+ Router</button>
            <button type="button" class="paletteBtn" data-type="swi">+ Switch</button>
            <button type="button" class="paletteBtn" data-type="pc">+ PC</button>
          </div>
          <div id="officeDefaultWrap" class="mini" style="display:flex;gap:8px;align-items:center"><span style="white-space:nowrap">Current office:</span><select id="defaultOfficeSel" class="officeSel" style="min-width:220px;max-width:240px"></select></div>
          <button id="clearTopo" class="mini">Clear Topology</button>
        </div>
        <div id="topoCanvas" class="out"></div>
        <div id="assignWrap" class="out">
          <div style="overflow:auto">
            <table id="assignTbl">
              <thead>
                <tr>
                  <th>#</th><th>Device</th><th>Type</th><th>Office</th><th>Subnet</th><th>Prefix</th><th>Gateway/Hint</th><th>Assigned IP</th><th>P2P (/31)</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </div>
      </div>

    </section>
      <section class="card" style="margin-top:16px">
        <h2 style="margin:0 0 8px">IP assignment policy</h2>
        <div class="out" style="font-size:14px;line-height:1.5">
          <ul style="margin:0 0 0 16px;">
            <li><b>Router</b> → Gateway (first usable host, <code>.1</code> In the block).</li>
            <li><b>Modem</b> → Last usable host on the first LAN (pool reserve).</li>
            <li><b>Switch</b> → Second to last usable host on the first LAN (after reserving the modem).</li>
            <li><b>PCs</b> → Rest of the pool by round‑robin.</li>
            <li><b>Enlaces P2P /31</b> → No gateway; Network pairs are assigned <code>Network/31</code> ↔ <code>broadcast/31</code> according to routers order.</li>
          </ul>
        </div>
      </section>
    
  
<div id="manualBackdrop" role="presentation" aria-hidden="true"></div>
<section id="manualModal" role="dialog" aria-modal="true" aria-labelledby="manualTitle" tabindex="-1">
  <div id="manualHeader">
    <h3 id="manualTitle">How IP-Easy Works — User Guide</h3>
    <div id="manualCloseNote" class="mini" style="background:#22304a;color:#cfe0f8;border-radius:10px;padding:6px 10px;font-weight:700;user-select:none">Close the page with ESC</div>
  </div>
  <div id="manualBody">
    <p class="muted" style="margin-top:-2px">This guide explains what <b>IP-Easy</b> is, how each panel works, and tips to export, copy and assign addresses consistently with your <b>IP assignment policy</b>.</p>

    <h4>What is IP-Easy?</h4>
    <p><b>IP-Easy</b> is a compact IPv4 planning toolkit. Enter any IPv4 address and it produces class info, wildcard, and a full set of <i>Quick Subnet Picks</i>. The <i>Subnet Designer — VLSM</i> reserves router-to-router <code>/31</code> links first and then fits your LANs with margin and gateway rules.</p>

    <div class="grid2">
      <div class="cardx">
        <h4>1) My Public IP Information</h4>
        <ul>
          <li>Auto-detects your current public IP, ISP, city/region, and country, and plots an approximate location on the map.</li>
        </ul>
      </div>
      <div class="cardx">
        <h4>2) Analyze (IPv4 address)</h4>
        <ul>
          <li>Type an IPv4 (e.g., <code>10.0.0.137</code>) and press <b>Analyze</b>.</li>
          <li><b>IP Summary</b>: class tag, classful mask, and wildcard.</li>
          <li><b>Binary</b>: dotted-binary representation (8 bits per octet) with a <b>Copy Binary</b> button.</li>
        </ul>
      </div>
    </div>

    <h4>Quick Subnet Picks</h4>
    <ul>
      <li>Shows network math for every prefix from <code>/32</code> to <code>/0</code>.</li>
      <li><span class="pill blue">P2P Link (RFC 3021)</span> marks <code>/31</code> — ideal for router-to-router links.</li>
      <li><span class="pill gray">Single Host</span> marks <code>/32</code> — use for loopbacks/host routes.</li>
      <li>Each row includes <b>Mask</b>, <b>Wildcard</b>, <b>Block Size</b>, <b>Network</b>, <b>First</b>, <b>Last</b>, and <b>Broadcast</b>, plus a <b>Copy</b> shortcut.</li>
      <li>When you specify <b>Devices needed</b> (if present), the smallest fitting row is highlighted as <b>Recommended</b>.</li>
    </ul>

    <h4>Subnet Designer — VLSM + Topology</h4>
    <ul>
      <li><b>Base block</b>: choose <code>Auto</code> (by class) or force a supernet (<code>/24</code>…<code>/20</code>).</li>
      <li><b>Router-to-Router links (<code>/31</code>)</b>: reserves that many <code>/31</code> pairs <i>first</i> inside the base block and lists them as <b>P2P Link (/31)</b> with both IPs and “P2P — no gateway”.</li>
      <li><b>Add 1 for gateway</b> (recommended): automatically accounts for the default gateway in each LAN.</li>
      <li><b>Add growth margin</b>: apply 10–50% overhead to size subnets for the future. Typical picks: Home/Micro 0–10%, Small Business 20–30%, Guests/Growth 50%+.</li>
      <li><b>Run VLSM</b>: packs LANs after reserving P2P links, returning <b>Network</b>, <b>Gateway</b>, <b>First</b>, <b>Last</b>, <b>Broadcast</b>, and <b>DHCP Pool</b>.</li>
    </ul>

    <h4>IP Assignment Policy (built-in)</h4>
    <ul>
      <li><b>Router</b> → gateway (first usable host, <code>.1</code> in the block).</li>
      <li><b>Modem</b> → last usable on the first LAN.</li>
      <li><b>Switch</b> → second-to-last usable on the first LAN (after reserving modem).</li>
      <li><b>PCs</b> → remaining pool, distributed round-robin across LANs.</li>
      <li><b>P2P /31</b> → no gateway; the two IPs of the /31 are paired by router order (odd → first IP, even → second IP).</li>
    </ul>

    <h4>Export & Utilities</h4>
    <ul>
      <li><b>Copy Binary</b>: copies dotted-binary to clipboard.</li>
      <li><b>Copy</b> (in tables): copies CSV-like row data (IP, prefix, mask, wildcard, etc.).</li>
      <li><b>Print</b>: prints the current page with your dark theme.</li>
      <li><b>Export PDF</b>: captures the full planner as a multi-page PDF (A4 portrait).</li>
    </ul>

    <h4>Tips</h4>
    <ul>
      <li>Use <b>/31</b> for point-to-point router links (<i>no waste, no gateway</i>).</li>
      <li>Use <b>/32</b> for loopbacks and single-host addressing.</li>
      <li>Prefer <b>.1</b> as the gateway convention for consistency with common ISPs and managed LANs.</li>
      <li>If a LAN does not fit the chosen base, try a larger base (e.g., move from <code>/24</code> to <code>/23</code>).</li>
    </ul>

    <h4>Ethical Use</h4>
    <p class="muted">IP-Easy is designed for legitimate IT planning, troubleshooting, and documentation.</p>
  </div>
</section>


<section id="p2pHelpModal" role="dialog" aria-modal="true" aria-labelledby="p2pHelpTitle" tabindex="-1">
  <div id="p2pHelpHeader">
    <h3 id="p2pHelpTitle">P2P /31 Router Links — Help</h3>
    <button type="button" id="p2pHelpClose">Close</button>
  </div>
  <div id="p2pHelpBody">
    <p class="muted">This helper explains how many <b>P2P /31</b> links you can model based on the number of routers in your topology.</p>
    <p>Each <code>/31</code> link connects exactly <b>two routers</b>. The maximum number of complete P2P links is:</p>
    <table>
      <thead>
        <tr>
          <th>Routers in topology</th>
          <th>Max complete /31 links</th>
          <th>Notes</th>
        </tr>
      </thead>
      <tbody>
        <tr><td>1</td><td>0</td><td>One router alone cannot form a P2P link.</td></tr>
        <tr><td>2</td><td>1</td><td>Both routers form a single /31 link.</td></tr>
        <tr><td>3</td><td>1</td><td>Two routers form one link; one router remains unused.</td></tr>
        <tr><td>4</td><td>2</td><td>Two independent P2P links (Router1–Router2, Router3–Router4).</td></tr>
        <tr><td>5</td><td>2</td><td>Four routers form two links; one router remains unused.</td></tr>
        <tr><td>6</td><td>3</td><td>Three complete P2P links.</td></tr>
        <tr><td>7</td><td>3</td><td>Six routers form three links; one router remains unused.</td></tr>
        <tr><td>8</td><td>4</td><td>Four complete P2P links.</td></tr>
        <tr><td>9</td><td>4</td><td>Eight routers form four links; one router remains unused.</td></tr>
        <tr><td>10</td><td>5</td><td>Five complete P2P links.</td></tr>
      </tbody>
    </table>
    <p><b>General rule:</b> the maximum number of complete links is <code>floor(routers / 2)</code>.</p>
    <ul>
      <li>If you enter a higher value in <b>Router-to-Router links (/31)</b>, IP-Easy will still reserve the extra /31 blocks, but some peers may not have a router assigned.</li>
      <li>Use <code>/31</code> for point-to-point router links (no wasted hosts, no gateway).</li>
      <li>Use <code>/32</code> for loopbacks and single-host addresses.</li>
    </ul>
    <p class="muted">Tip: design your physical or logical topology first (how many routers and links you want), then set <b>Router-to-Router links (/31)</b> so it matches the number of real P2P links you plan to deploy.</p>
  </div>
</section>
<div id="p2pHelpBackdrop" aria-hidden="true"></div>

</main>

<script>
/* ===== helpers ===== */
const $ = s => document.querySelector(s);
const oct = s => s.split('.').map(n=>Number(n));
function validIPv4(ip){return /^\d+\.\d+\.\d+\.\d+$/.test(ip) && oct(ip).every(x=>x>=0&&x<=255)}
function ipToInt(ip){return oct(ip).reduce((a,o)=>(a<<8)+o,0)>>>0}
function intToIp(n){return [24,16,8,0].map(s=>(n>>>s)&255).join('.')}
function ipClass(ip){const f=oct(ip)[0];
  if(f>=1 && f<=126) return 'A';
  if(f===127) return 'Loopback (127/8)';
  if(f>=128 && f<=191) return 'B';
  if(f>=192 && f<=223) return 'C';
  if(f>=224 && f<=239) return 'D (Multicast)';
  return 'E (Reserved)';
}
function dottedFromCIDR(n){const bits='1'.repeat(n).padEnd(32,'0');return bits.match(/.{1,8}/g).map(b=>parseInt(b,2)).join('.')}
function wildcardFromMask(dot){return dot.split('.').map(x=>255-Number(x)).join('.')}
function calcBlockOctet(cidr){return (cidr<=8)?1:(cidr<=16)?2:(cidr<=24)?3:4}
function calcNet(ipInt, cidr){
  const mask = cidr===0?0:(~0 << (32-cidr))>>>0;
  const net = ipInt & mask; const bc = net | (~mask>>>0);
  const total = 2**(32-cidr);
  let usable=0, first='', last='';
  if(cidr===32){usable=1; first=last=intToIp(ipInt)}
  else if(cidr===31){usable=2; first=intToIp(net); last=intToIp(bc)}
  else {usable=Math.max(0,total-2); first=intToIp(net+1); last=intToIp(bc-1)}
  return {network:intToIp(net), broadcast:intToIp(bc), total, usable, first, last};
}
function toBinaryDotted(ip){ return oct(ip).map(n=>n.toString(2).padStart(8,'0')).join('.'); }
function annotate(ip){
  const [f,s]=oct(ip); const tags=[];
  if((f===10) || (f===172 && s>=16 && s<=31) || (f===192 && s===168)) tags.push('Private');
  if(f===127) tags.push('Loopback');
  if(f===169 && s===254) tags.push('Link-local (APIPA)');
  if(f>=224 && f<=239) tags.push('Multicast');
  if(f>=240) tags.push('Reserved');
  return tags;
}

/* ===== table builder ===== */
const CIDRS = Array.from({length:32}, (_,i)=>32 - i);
function buildTable(ip){
  const tbody = $('#tbl tbody'); tbody.innerHTML='';
  if(!validIPv4(ip)) return [];
  const ipInt = ipToInt(ip);
  const rows = [];
  for(const c of CIDRS){
    let badge = '';
    if(c===31){ badge = ' <span class="pill blue">P2P Link (RFC 3021)</span>'; }
    else if(c===32){ badge = ' <span class="pill gray">Single Host</span>'; }
    const info = calcNet(ipInt,c);
    // --- IP-Easy display policy to match VLSM table ---
    // If 'Add 1 for gateway' is checked in VLSM, advance First by +1 (.2 in /24)
    // Always reserve the last usable for the Switch on display (Last -> -1), except for /31 and /32
    const addGwChk = document.getElementById('addGw');
    const addGwFlag = addGwChk ? !!addGwChk.checked : true; // default true if toggle not present
    let firstDisp = info.first, lastDisp = info.last;
    if (c <= 30 && c !== 31 && c !== 32) {
      if (addGwFlag) {
        // move first up by one host
        const fInt = ipToInt(info.first) + 1;
        firstDisp = intToIp(fInt);
      }
      // reserve last usable for switch on display
      const lInt = ipToInt(info.last) - 1;
      lastDisp = intToIp(lInt);
    }
    const mask = dottedFromCIDR(c);
    const wc = wildcardFromMask(mask);
    const blockOct = calcBlockOctet(c);
    const block = 256 - mask.split('.')[blockOct-1];
    const tr = document.createElement('tr');
    tr.dataset.usable = info.usable;
    tr.dataset.cidr = c;
    tr.innerHTML = `
      <td>${info.usable}</td>
      <td>/${c}${badge}</td>
      <td>${mask}</td>
      <td>${wc}</td>
      <td>${block} (octet ${blockOct})</td>
      <td>${info.network}</td>
      <td>${firstDisp}</td>
      <td>${lastDisp}</td>
      <td>${info.broadcast}</td>
      <td><button class="mini copy" data-copy="${ip},/${c},${mask},${wc},${info.network},${firstDisp},${lastDisp},${info.broadcast}">Copy</button></td>`;
    tbody.appendChild(tr);
    rows.push({cidr:c, mask, wc, block, blockOct, ...info});
  }
  tbody.querySelectorAll('button.copy').forEach(btn=>{
    btn.addEventListener('click', e=>{
      const text = e.currentTarget.getAttribute('data-copy');
      navigator.clipboard.writeText(text);
      e.currentTarget.textContent = 'Copied!';
      setTimeout(()=> e.currentTarget.textContent='Copy', 900);
    });
  });
  return rows;
}
function recommendSubnet(devices){
  const need = Math.max(devices, 2);
  const rows = Array.from($('#tbl tbody').rows);
  let picked = null;
  for(const r of rows){ const usable = Number(r.dataset.usable); if(usable >= need){ picked = r; break; } }
  rows.forEach(r=> r.classList.remove('recommended'));
  if(picked){ picked.classList.add('recommended'); picked.scrollIntoView({behavior:'smooth',block:'center'}); }
  return picked;
}

/* =========== Geo lookup + map for the ENTERED IP =========== */
let _leafletMap = null;
async function loadGeo(ip){
  const infoEl = document.getElementById('geoInfo'); const mapEl  = document.getElementById('geoMap');
  infoEl.innerHTML = '<div>Loading IP info...</div>'; mapEl.innerHTML  = '';
  if(_leafletMap){ _leafletMap.remove(); _leafletMap = null; }
  try{
    const res = await fetch(`https://ipapi.co/${encodeURIComponent(ip)}/json/`, {cache:'no-store'});
    if(!res.ok) throw new Error('geo http ' + res.status);
    const data = await res.json();
    const html = `
      <div><b>IPv4:</b> ${data.ip ?? '—'}</div>
      <div><b>ISP:</b> ${data.org ?? '—'}</div>
      <div><b>City:</b> ${data.city ?? '—'}</div>
      <div><b>Region:</b> ${data.region ?? '—'}</div>
      <div><b>Country:</b> ${data.country_name ?? '—'}</div>`;
    infoEl.innerHTML = html;
    if(Number.isFinite(data.latitude) && Number.isFinite(data.longitude)){
      _leafletMap = L.map('geoMap').setView([data.latitude, data.longitude], 8);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap contributors' }).addTo(_leafletMap);
      L.marker([data.latitude, data.longitude]).addTo(_leafletMap).bindPopup(`<b>${data.city || ''}${data.city?', ':''}${data.region || ''}</b><br>${data.org || ''}`);
    }else{ mapEl.innerHTML = '<div class="muted" style="padding:8px">No map available for this IP.</div>'; }
  }catch(err){
    console.error(err); infoEl.innerHTML = '<div style="color:#f88">Failed to load IP information.</div>'; mapEl.innerHTML = '';
  }
}

/* ===== Auto IP Discover ===== */
async function autoDiscoverIP(){
  try{
    const res = await fetch('https://ipapi.co/json/', {cache:'no-store'});
    const data = await res.json();
    if(data && data.ip && validIPv4(data.ip)){
      // Decoupled: only update My IP panel; do NOT change the Analyze input or Quick Subnet Picks
      loadGeo(data.ip);
    } else {
      // Fallback: keep panel message
      document.getElementById('geoInfo').innerHTML = '<div>Public IP not available.</div>';
      document.getElementById('geoMap').innerHTML = '';
    }
  }catch(e){
    document.getElementById('geoInfo').innerHTML = '<div>Public IP discover failed.</div>';
    document.getElementById('geoMap').innerHTML = '';
  }
}

/* =================== analyze() + hooks =================== */
function analyze(){
  const ip = $('#ip').value.trim();
  const needStr = (document.getElementById('need') ? document.getElementById('need').value.trim() : '');
  if(!validIPv4(ip)){
    $('#quick').textContent='Invalid IPv4.'; $('#bin').textContent='—'; $('#tbl tbody').innerHTML=''; $('#gwHint').textContent='';
    document.getElementById('geoInfo').innerHTML = '<div>Enter an IP and click <b>Analyze</b> to see ISP, city, region and country here.</div>';
    document.getElementById('geoMap').innerHTML=''; if(_leafletMap){ _leafletMap.remove(); _leafletMap=null; }
    return;
  }
  const cls = ipClass(ip), tags = annotate(ip).map(t=>`<span class="pill">${t}</span>`).join(' ');
  const classfulMask = (cls==='A')?'/8': (cls==='B')?'/16': (cls==='C')?'/24': '—';
  const maskDot = (classfulMask==='—')?'—':dottedFromCIDR(Number(classfulMask.slice(1)));
  $('#quick').innerHTML = `
    <div><b>IP:</b> ${ip}</div>
    <div><b>Class:</b> <span class="pill">${cls}</span> ${tags?(' '+tags):''}</div>
    <div><b>Default (classful) mask:</b> ${classfulMask} ${maskDot!=='—'?('('+maskDot+')'):''}</div>
    <div><b>Wildcard (classful):</b> ${maskDot!=='—'? wildcardFromMask(maskDot):'—'}</div>`;
  const binTxt = toBinaryDotted(ip); $('#bin').textContent = binTxt;
  buildTable(ip);
  $('#gwHint').textContent = '';
  if(needStr){
    const need = Number(needStr);
    const picked = recommendSubnet(need);
    if(picked){
      const cells = picked.cells, cidr = cells[1].textContent, network = cells[5].textContent, first = cells[6].textContent;
      $('#gwHint').textContent = `Devices needed: ${need}. Recommended subnet ${cidr} at network ${network}. Suggested gateway: ${first}`;
    } else { $('#gwHint').textContent = `Devices needed: ${need}. None of the listed subnets fit.`; }
  }
  $('#copyBin').onclick = ()=>{ navigator.clipboard.writeText(binTxt); $('#copyBin').textContent='Copied!'; setTimeout(()=>$('#copyBin').textContent='Copy Binary',900); };
  $('#exportPdf').onclick = async ()=>{
    const { jsPDF } = window.jspdf; const mainEl = document.querySelector('main'); if(!mainEl){ return; }
    const baseBg = getComputedStyle(document.body).backgroundColor || '#0b0b0f';
    const canvas = await html2canvas(mainEl, { scale: 2, backgroundColor: baseBg, useCORS: true });
    const imgW = canvas.width, imgH = canvas.height; const pdf = new jsPDF('p','pt','a4');
    const pageWidth  = pdf.internal.pageSize.getWidth(), pageHeight = pdf.internal.pageSize.getHeight();
    const scale = pageWidth / imgW, slicePixelHeight = Math.floor(pageHeight / scale);
    const tmp = document.createElement('canvas'); const tctx = tmp.getContext('2d');
    for (let y = 0, page = 0; y < imgH; y += slicePixelHeight, page++) {
      const sliceH = Math.min(slicePixelHeight, imgH - y); tmp.width = imgW; tmp.height = sliceH;
      tctx.clearRect(0,0,tmp.width,tmp.height); tctx.drawImage(canvas, 0, y, imgW, sliceH, 0, 0, imgW, sliceH);
      const imgData = tmp.toDataURL('image/png'); if (page > 0) pdf.addPage(); pdf.addImage(imgData, 'PNG', 0, 0, pageWidth, sliceH * scale);
    }
    const ipVal = (document.getElementById('ip')?.value || 'ip-easy').replace(/\./g,'-'); pdf.save(`ip-easy_${ipVal}.pdf`);
  };
  $('#printPage').onclick = ()=> window.print();
  // decoupled: do not refresh My IP panel from analyze()
}
document.getElementById('go').onclick = analyze;
// Auto-discover public IP on load (decoupled)
window.addEventListener('DOMContentLoaded', ()=>{ try{ autoDiscoverIP(); }catch(_){} });
document.getElementById('ip').addEventListener('keydown',e=>{ if(e.key==='Enter') analyze(); });
if (document.getElementById('need')) { document.getElementById('need').addEventListener('keydown',e=>{ if(e.key==='Enter') analyze(); }); }
/* ===== VLSM ===== */
// --- LAN blocks UI ---
function makeLanCard(idx, name='', pcs=1){
  const div=document.createElement('div');
  div.className='lanCard';
  div.innerHTML = `<div class="lanHead">
                     <input class="lanName" placeholder="LAN / Office ${idx+1}" value="${name||''}"/>
                     <div class="lanBtns">
                       <button class="lanDel" title="Remove">×</button>
                     </div>
                   </div>
                   <div class="lanDevices" style="display:flex;gap:6px;flex-wrap:wrap;margin-top:8px">
                     <button class="mini addModem"  title="Add Modem">+ Modem</button>
                     <button class="mini addRouter" title="Add Router">+ Router</button>
                     <button class="mini addSwitch" title="Add Switch">+ Switch</button>
                     <button class="mini addPC"     title="Add PC">+ PC</button>
                   </div>`;
  div.querySelector('.lanDel').addEventListener('click', ()=> { const name=(div.querySelector('.lanName')?.value||'').trim()||`Office ${idx+1}`; div.remove(); removeOfficeData(name); });
  // Wire device adders (UI only; delegating creation to existing addDevice logic)
  const wire = (cls, type)=>{
    const btn = div.querySelector(cls);
    if(btn){ btn.addEventListener('click', ()=> addOfficeDevice(div, idx, type)); }
  };
  wire('.addModem',  'mdm');
  wire('.addRouter', 'rtr');
  wire('.addSwitch', 'swi');
  wire('.addPC',     'pc');
  return div;

}
function addLan(name='', pcs=1){
  const wrap=document.getElementById('lanBlocks'); if(!wrap) return;
  const idx=wrap.children.length; wrap.appendChild(makeLanCard(idx,name,pcs));
}

function removeOfficeData(officeName){
  // 1) Remove VLSM rows for this office (keep P2P and other offices)
  try{
    const vtbody = document.querySelector('#vlsmTbl tbody');
    if (vtbody){
      Array.from(vtbody.querySelectorAll('tr')).forEach(tr=>{
        const cell = tr.children[0] ? tr.children[0].textContent.trim() : '';
        if (cell === officeName) tr.remove();
      });
    }
  }catch(e){ /* no-op */ }

  // 2) Remove devices in this office from topology + assignment
  try{
    // remove matching nodes from canvas/topoDevices
    const nodes = Array.from(document.querySelectorAll('#topoCanvas .node'));
    nodes.forEach(node=>{
      const sel = node.querySelector('.officeSel');
      const off = sel ? sel.value : 'Unassigned';
      if (off === officeName){
        const id = node.id;
        if (typeof removeDevice === 'function'){ removeDevice(id); }
        else if (node.parentNode){ node.parentNode.removeChild(node); }
      }
    });
    // re-render table after removals
    if (typeof renderAssignTable === 'function'){ renderAssignTable(); }
  }catch(e){ /* no-op */ }
}

function clearLan(){
  const wrap=document.getElementById('lanBlocks');
  if(wrap) wrap.innerHTML='';
  // Wipe all results & topology so the user can start fresh
  const vBody = document.querySelector('#vlsmTbl tbody'); if (vBody) vBody.innerHTML='';
  const aBody = document.querySelector('#assignTbl tbody'); if (aBody) aBody.innerHTML='';
  const note = document.getElementById('comcastNote'); if (note) note.style.display='none';
  const s23 = document.getElementById('super23'); if (s23) s23.textContent='';
  const s22 = document.getElementById('super22'); if (s22) s22.textContent='';
  if (typeof clearTopology === 'function') clearTopology();
  if (typeof _nodeSeq !== 'undefined') _nodeSeq = 1;
}
setTimeout(()=>{
  const addBtn=document.getElementById('addLan'); const clr=document.getElementById('clearLan');
  if(addBtn) addBtn.addEventListener('click', ()=> addLan('', 8));
  if(clr) clr.addEventListener('click', clearLan);
},0);
function collectLANNames(){
  const wrap=document.getElementById('lanBlocks'); if(!wrap) return [];
  return [...wrap.querySelectorAll('.lanCard')].map((card,i)=>{
    const n=(card.querySelector('.lanName')?.value||'').trim()||`Office ${i+1}`; return n;
  });
}
function countDevicesByOffice(){
  const counts={};
  const names = collectLANNames();
  names.forEach(n=>counts[n]=0);
  // read from node selects (added by addon)
  document.querySelectorAll('#topoCanvas .node').forEach(node=>{
    const sel = node.querySelector('.officeSel');
    const off = (sel && sel.value) ? sel.value : 'Unassigned';
    // Only count if office exists in LAN list; ignore Unassigned
    if(counts.hasOwnProperty(off)) counts[off] = (counts[off]||0) + 1;
  });
  return counts; // {OfficeX: count}
}
function collectNeedsFromLAN(){
  const wrap=document.getElementById('lanBlocks'); if(!wrap) return [];
  return [...wrap.querySelectorAll('.lanPcs')].map(e=>Number(e.value)).filter(n=>Number.isFinite(n) && n>0);
}

function parseNeedsList(txt){ return txt.split(/[^0-9]+/).map(x=>Number(x)).filter(x=>Number.isFinite(x) && x>0); }
function nextPow2Hosts(n){
  for(let c=32;c>=0;c--){
    if(c===32){ if(n<=1) return 32; }
    else if(c===31){ if(n<=2) return 31; }
    else{ const usable=Math.max(0,(2**(32-c))-2); if(usable>=n) return c; }
  } return 0;
}
function alignDown(n,c){ const mask=c===0?0:(~0<<(32-c))>>>0; return n & mask; }
function alignUp(n,c){ const size=2**(32-c); return (n + size - 1) & ~(size - 1); }
function classfulBaseCIDR(cls){ if(cls==='A')return 8; if(cls==='B')return 16; if(cls==='C')return 24; return 24; }
function computeBase(ipInt,cls,baseSel){ let baseCidr=(baseSel==='auto')?classfulBaseCIDR(cls):Number(baseSel); const baseNet=alignDown(ipInt,baseCidr); const baseBc=baseNet | (~((~0<<(32-baseCidr))>>>0))>>>0; return {baseCidr,baseNet,baseBc}; }
function toDhcpPool(firstInt,lastInt){ const start=firstInt+1,end=lastInt-1; return (end>=start)? (intToIp(start)+' - '+intToIp(end)):'—'; }
function updateSupernetHints(ipInt){
  const c23=23,c22=22, n23=alignDown(ipInt,c23), b23=n23 | (~((~0<<(32-c23))>>>0))>>>0, n22=alignDown(ipInt,c22), b22=n22 | (~((~0<<(32-c22))>>>0))>>>0;
  document.getElementById('super23').textContent='Supernet /23 around your IP: '+intToIp(n23)+' - '+intToIp(b23)+' (contains two /24s)';
  document.getElementById('super22').textContent='Supernet /22 around your IP: '+intToIp(n22)+' - '+intToIp(b22)+' (contains four /24s)';
}
function runVLSM(){
  const ip=document.getElementById('ip').value.trim();
  const tbody=document.querySelector('#vlsmTbl tbody'); tbody.innerHTML='';
  if(!validIPv4(ip)){ alert('Enter a valid IPv4 first.'); return; }

  const ipInt=ipToInt(ip), cls=ipClass(ip);
  const baseSel=document.getElementById('vlsmBase').value;
  const {baseCidr,baseNet,baseBc}=computeBase(ipInt,cls,baseSel);
  document.getElementById('comcastNote').style.display=(baseCidr===24 && baseNet===ipToInt('10.0.0.0'))?'block':'none';

  // Build needs from Topology by office
  const officeCounts = countDevicesByOffice(); // {Office:count}
  // If no offices defined, bail
  const offices = Object.keys(officeCounts);
  if(offices.length===0){ alert('Add at least one Office/LAN.'); return; }

  // Apply options: margin + gateway
  const addGw = document.getElementById('addGw').checked;
  const addMargin = document.getElementById('addMargin').checked;
  const pct = Number(document.getElementById('marginPct').value||0);

  const needsArr = offices.map(name=>{
    let n = officeCounts[name]||0;
    if(addMargin) n = Math.ceil(n*(1+(pct/100)));
    if(addGw) n = Math.max(1,n+1);
    return {name, need: n};
  });

  // Sort by need desc but keep office order when needs are equal
  needsArr.sort((a,b)=>{
    if (b.need !== a.need) return b.need - a.need;
    return a.name.localeCompare(b.name);
  });

  
  // === Reserve Router-to-Router /31 links first (if any) ===
  const p2pInput = document.getElementById('p2pLinks');
  const p2pCount = Math.max(0, Number(p2pInput ? p2pInput.value : 0) | 0);
  let lanStart = baseNet;
  if(p2pCount>0){
    let p2pCursor = baseNet;
    for(let i=0;i<p2pCount;i++){
      const cidr=31, size=2**(32-cidr);
      p2pCursor = alignUp(p2pCursor, cidr);
      const subnetNet=p2pCursor, subnetBc=subnetNet+size-1;
      if(subnetBc> baseBc){
        const tr=document.createElement('tr');
        tr.innerHTML = `<td>P2P Link (/31)</td><td>2</td><td>/${cidr}</td><td>${dottedFromCIDR(cidr)}</td><td>${wildcardFromMask(dottedFromCIDR(cidr))}</td>
          <td>${intToIp(subnetNet)}</td><td>P2P — no gateway</td><td>${intToIp(subnetNet)}</td><td>${intToIp(subnetBc)}</td><td>${intToIp(subnetBc)}</td><td>—</td>`;
        tbody.appendChild(tr);
        p2pCursor = subnetBc + 1;
      }else{
        const tr=document.createElement('tr');
        tr.innerHTML = `<td>P2P Link (/31)</td><td>2</td><td>/${cidr}</td><td>${dottedFromCIDR(cidr)}</td><td>${wildcardFromMask(dottedFromCIDR(cidr))}</td>
          <td>${intToIp(subnetNet)}</td><td>P2P — no gateway</td><td>${intToIp(subnetNet)}</td><td>${intToIp(subnetBc)}</td><td>${intToIp(subnetBc)}</td><td>—</td>`;
        tbody.appendChild(tr);
        p2pCursor = subnetBc + 1;
      }
    }
    lanStart = p2pCursor;
  }
// VLSM pack inside base
  let cursor=lanStart, end=baseBc;
  for(const item of needsArr){
    const need=item.need;
    let cidr;
  if (needsArr.length === 1 && (p2pCount === 0)) {
    // Force LAN to use the Base block prefix so it matches the classful logic in IP Summary
    cidr=Number(baseCidr);
  } else {
    cidr = nextPow2Hosts(need);
  }
  const size = 2 ** (32 - cidr);
  cursor = alignUp(cursor, cidr);

    const subnetNet=cursor, subnetBc=subnetNet+size-1;
    if(subnetBc> end){
      const tr=document.createElement('tr');
      tr.innerHTML=`<td>${item.name}</td><td>${need}</td><td colspan="9" style="color:#ffa8a8">Does not fit inside ${intToIp(baseNet)}/${baseCidr}. Try a larger base.</td>`;
      tbody.appendChild(tr); continue;
    }
    const mask=dottedFromCIDR(cidr), wc=wildcardFromMask(mask);
    let firstInt, lastInt, gw, first, last;
    if(cidr===32){ firstInt=lastInt=subnetNet; gw=intToIp(subnetNet); first=last=gw; }
    else if(cidr===31){ firstInt=subnetNet; lastInt=subnetBc; gw=intToIp(firstInt); first=intToIp(firstInt); last=intToIp(lastInt); }
    else {
      // Usable host range (raw, without reservations)
      firstInt = subnetNet + 1;
      lastInt  = subnetBc  - 1;
      // Display policy: if gateway is reserved, move "First" one up; always reserve last usable for Switch
      const swReserved = true;
      let dispFirst = firstInt + (addGw ? 1 : 0);
      let dispLast  = lastInt  - (swReserved ? 1 : 0);
      gw    = intToIp(firstInt);
      first = intToIp(dispFirst);
      last  = intToIp(dispLast);
    }
    // DHCP pool remains firstInt+1 .. lastInt-1 (excludes gateway and switch automatically)
    const dhcp=(cidr<=30)? toDhcpPool(firstInt,lastInt) : '—';

    const tr=document.createElement('tr');
    tr.innerHTML=`<td>${item.name}</td><td>${need}</td><td>/${cidr}</td><td>${mask}</td><td>${wc}</td>
      <td>${intToIp(subnetNet)}</td><td>${gw}</td><td>${first}</td><td>${last}</td><td>${intToIp(subnetBc)}</td><td>${dhcp}</td>`;
    tbody.appendChild(tr);
    cursor=subnetBc+1;
  }
  updateSupernetHints(ipInt);
  assignIPsFromVLSM();
}
document.getElementById('runVlsm').onclick=runVLSM;
document.getElementById('clearVlsm').onclick=()=>{ document.getElementById('vlsmList').value=''; document.querySelector('#vlsmTbl tbody').innerHTML=''; document.getElementById('comcastNote').style.display='none'; document.getElementById('super23').textContent=''; document.getElementById('super22').textContent=''; };

/* ===================== Topology Builder logic (merged) ===================== */
const topoCanvas=document.getElementById('topoCanvas');
const topoAssignBody=document.querySelector('#assignTbl tbody');
let topoDevices=[]; // {id,type:'mdm|rtr|swi|pc',name,x,y,ip:null,subnet:null,gw:null,prefix:null}
let _nodeSeq=1;

function nextName(type){
  const m={mdm:'Modem',rtr:'Router',swi:'Switch',pc:'PC'};
  const base=m[type]||'Dev';
  const n=topoDevices.filter(d=>d.type===type).length+1;
  return `${base}${n}`;
}
function addDevice(type){
  if(!topoCanvas) return;
  const id='n'+(_nodeSeq++);
  const name=nextName(type);
  const node={id,type,name,x:12+(topoDevices.length*6)%180,y:12+(topoDevices.length*12)%220,ip:null,subnet:null,gw:null,prefix:null};
  topoDevices.push(node);
  renderNode(node);
  renderAssignTable();
}
function removeDevice(id){
  const idx=topoDevices.findIndex(d=>d.id===id);
  if(idx>=0){ topoDevices.splice(idx,1); }
  const el=document.getElementById(id);
  if(el && el.parentNode) el.parentNode.removeChild(el);
  renderAssignTable();
}
function clearTopology(){ topoDevices=[]; if(topoCanvas) topoCanvas.innerHTML=''; renderAssignTable(); }

function renderNode(n){
  const el=document.createElement('div');
  el.className=`node ${n.type}`; el.id=n.id;
  el.style.left=n.x+'px'; el.style.top=n.y+'px';
  el.innerHTML=`<span class="dot"></span><span class="tag">${n.name}</span><button class="kill" title="Remove">×</button>`;
  topoCanvas.appendChild(el);
  el.querySelector('.kill').addEventListener('click', (e)=>{ e.stopPropagation(); removeDevice(n.id); });
  enableDrag(el,n);
}
function enableDrag(el,n){
  let sx=0,sy=0,ox=0,oy=0,dragging=false;
  el.addEventListener('pointerdown',e=>{ dragging=true; el.setPointerCapture(e.pointerId); sx=e.clientX; sy=e.clientY; ox=parseInt(el.style.left)||0; oy=parseInt(el.style.top)||0; });
  el.addEventListener('pointermove',e=>{ if(!dragging) return; const dx=e.clientX-sx, dy=e.clientY-sy;
    n.x=Math.max(0,Math.min(topoCanvas.clientWidth-80,ox+dx));
    n.y=Math.max(0,Math.min(topoCanvas.clientHeight-34,oy+dy));
    el.style.left=n.x+'px'; el.style.top=n.y+'px';
  });
  el.addEventListener('pointerup',()=>{dragging=false;});
}
function renderAssignTable(){
  if(!topoAssignBody) return;
  topoAssignBody.innerHTML='';
  topoDevices.forEach((d,i)=>{
    const tr=document.createElement('tr');
    const typeTxt = (d.type==='mdm')?'Modem':(d.type==='rtr')?'Router':(d.type==='swi')?'Switch':'PC';
    const nodeEl = document.getElementById(d.id);
    const offSel = nodeEl ? nodeEl.querySelector('.officeSel') : null;
    const off = offSel ? offSel.value : 'Unassigned';
    tr.innerHTML=`
      <td>${i+1}</td><td>${d.name}</td><td>${typeTxt}</td><td>${off}</td>
      <td>${d.subnet??'—'}</td><td>${d.prefix??'—'}</td><td>${d.gw??'—'}</td><td>${d.ip??'—'}</td><td>${d.p2p??'—'}</td>`;
    topoAssignBody.appendChild(tr);
  });
}

/* === Read VLSM table and assign IPs === */
function getVlsmRows(){
  const table=document.getElementById('vlsmTbl'); if(!table) return [];
  const rows=[...table.querySelectorAll('tbody tr')];
  return rows.map(r=>{
    const t=[...r.cells].map(c=>c.textContent.trim());
    if(t.length<11 || !t[2]?.startsWith('/')) return null;
    const office=t[0];
    const prefix=Number(t[2].replace('/',''));
    return { office, need:Number(t[1])||0, prefix, network:t[5], gateway:t[6], first:t[7], last:t[8], broadcast:t[9] };
  }).filter(Boolean);
}
function ipToInt_(ip){return ip.split('.').map(n=>+n).reduce((a,o)=>(a<<8)+o,0)>>>0}
function intToIp_(n){return [24,16,8,0].map(s=>(n>>>s)&255).join('.')}




    function assignIPsFromVLSM(){
      const subs = getVlsmRows();

      // Reset current assignments
      topoDevices.forEach(d => {
        d.ip     = null;
        d.subnet = null;
        d.gw     = null;
        d.prefix = null;
        d.p2p    = null;
      });

      if (!subs.length || !topoDevices.length){
        renderAssignTable();
        return;
      }

      // Helpers
      function ipToInt_(ip){
        return ip.split('.').reduce((a,o)=> (a<<8) + parseInt(o,10), 0) >>> 0;
      }
      function intToIp_(n){
        return [
          (n>>>24)&255,
          (n>>>16)&255,
          (n>>>8)&255,
          n&255
        ].join('.');
      }

      const p2pPools = [];
      const lanPools = [];

      // Build address pools from VLSM rows
      subs.forEach(s => {
        const prefix = s.prefix;

        // /31 – point‑to‑point, two usable IPs, no gateway
        if (prefix === 31){
          const hosts = [s.first, s.last]; // table already stores the two link IPs
          p2pPools.push({ s, hosts });
          return;
        }

        // /32 – single‑host block
        if (prefix === 32){
          const hosts = [s.first];
          lanPools.push({ s, hosts });
          return;
        }

        // Normal LAN: recompute full usable range from Network + Prefix
        const netInt   = ipToInt_(s.network);           // network address
        const size     = Math.pow(2, 32 - prefix);      // total addresses in block
        const bcInt    = netInt + size - 1;             // broadcast
        const firstInt = netInt + 1;                    // gateway (.1 in a /24)
        const lastInt  = bcInt - 1;                     // last usable host

        const hosts = [];
        // Host list excludes the gateway; PCs will start at .2
        for (let n = firstInt + 1; n <= lastInt; n++){
          hosts.push(intToIp_(n));
        }

        lanPools.push({ s, hosts });
      });

      // Generic "take first free IP" from a pool collection
      function takeFrom(pools){
        for (let i = 0; i < pools.length; i++){
          const pool = pools[i];
          if (pool.hosts.length){
            const ip = pool.hosts.shift();
            let peer = null;

            if (pool.s.prefix === 31){
              // determine the peer for the /31 link
              peer = (ip === pool.s.first) ? pool.s.last : pool.s.first;
            }

            return { ip, sub: pool.s, peer };
          }
        }
        return { ip: null, sub: null, peer: null };
      }

      const routerPairs = [];

      // 1) Routers – prefer /31 links, then fall back to LANs
      topoDevices.filter(d => d.type === 'rtr').forEach(d => {
        let t = takeFrom(p2pPools);
        if (!t.ip) t = takeFrom(lanPools);

        if (t.ip && t.sub){
          d.subnet = t.sub.network;
          d.prefix = '/' + t.sub.prefix;
          d.gw     = (t.sub.prefix === 31) ? 'P2P — no gateway' : (t.sub.gateway || '');
          d.ip     = t.ip;
          d.p2p    = (t.sub.prefix === 31) ? (t.sub.network + '/31 • peer ' + t.peer) : '—';

          if (t.sub.prefix === 31){
            routerPairs.push({
              cidr: t.sub.network + '/31',
              a: t.ip,
              b: t.peer
            });
          }
        } else {
          d.subnet = '—';
          d.prefix = '—';
          d.gw     = '—';
          d.ip     = '—';
          d.p2p    = '—';
        }
      });

      // 2) Modem – last usable IP of FIRST LAN block
      const modemDevices  = topoDevices.filter(d => d.type === 'mdm');
      const switchDevices = topoDevices.filter(d => d.type === 'swi');

      if (lanPools.length){
        const firstLan = lanPools[0];

        // Reserve last host for modem(s)
        modemDevices.forEach(d => {
          if (firstLan.hosts.length){
            const ip = firstLan.hosts.pop(); // highest remaining IP
            d.subnet = firstLan.s.network;
            d.prefix = '/' + firstLan.s.prefix;
            d.gw     = firstLan.s.gateway || '';
            d.ip     = ip;
            d.p2p    = '—';
          } else {
            d.subnet = '—';
            d.prefix = '—';
            d.gw     = '—';
            d.ip     = '—';
            d.p2p    = '—';
          }
        });

        // 3) Switch – second‑to‑last usable IP of FIRST LAN block
        switchDevices.forEach(d => {
          if (firstLan.hosts.length){
            const ip = firstLan.hosts.pop(); // now penultimate after modem reservation
            d.subnet = firstLan.s.network;
            d.prefix = '/' + firstLan.s.prefix;
            d.gw     = firstLan.s.gateway || '';
            d.ip     = ip;
            d.p2p    = '—';
          } else {
            d.subnet = '—';
            d.prefix = '—';
            d.gw     = '—';
            d.ip     = '—';
            d.p2p    = '—';
          }
        });
      } else {
        // No LANs at all: mark modem/switch as unassigned
        modemDevices.concat(switchDevices).forEach(d => {
          d.subnet = '—';
          d.prefix = '—';
          d.gw     = '—';
          d.ip     = '—';
          d.p2p    = '—';
        });
      }

      // 4) PCs – consume remaining LAN addresses round‑robin across all LAN pools
      const pcDevices = topoDevices.filter(d => d.type === 'pc');
      let lanIndex = 0;

      pcDevices.forEach(d => {
        let assigned = false;

        for (let attempts = 0; attempts < lanPools.length; attempts++){
          const pool = lanPools[lanIndex % lanPools.length];
          lanIndex++;

          if (pool.hosts.length){
            const ip = pool.hosts.shift();
            d.subnet = pool.s.network;
            d.prefix = '/' + pool.s.prefix;
            d.gw     = pool.s.gateway || '';
            d.ip     = ip;
            d.p2p    = '—';
            assigned = true;
            break;
          }
        }

        if (!assigned){
          d.subnet = '—';
          d.prefix = '—';
          d.gw     = '—';
          d.ip     = '—';
          d.p2p    = '—';
        }
      });

      // Finally, refresh the table and P2P summary
      renderAssignTable();
      buildP2PSummary(routerPairs);
    }



/* Bind palette */
document.querySelectorAll('.paletteBtn').forEach(btn=> btn.addEventListener('click', ()=> addDevice(btn.dataset.type)));
document.getElementById('clearTopo').addEventListener('click', clearTopology);
</script>

<script>
// === SAFE ADDON: Office selectors for nodes + per-office assignment ===
(function(){
  const $ = s => document.querySelector(s);
  const $$ = s => Array.from(document.querySelectorAll(s));

  // Helper: read LAN office names
  function getOfficeNames(){
    const wrap = document.getElementById('lanBlocks');
    if(!wrap) return [];
    const cards = Array.from(wrap.querySelectorAll('.lanCard'));
    return cards.map((c,i)=> (c.querySelector('.lanName')?.value||'').trim() || `Office ${i+1}`);
  }

  // Attach a small <select> to each node for office assignment (non-invasive)
  function attachOfficeSelect(nodeEl){
    if(!nodeEl || nodeEl.querySelector('.officeSel')) return;
    const sel = document.createElement('select');
    sel.className = 'officeSel';
    const opts = ['Unassigned', ...getOfficeNames()].map(n=>`<option value="${n}">${n}</option>`).join('');
    sel.innerHTML = opts;
    sel.addEventListener('change', ()=> refreshAssignOfficeColumn());
    // insert before delete button if exists
    const kill = nodeEl.querySelector('button.kill');
    if(kill && kill.parentNode){ kill.parentNode.insertBefore(sel, kill); }
    else { nodeEl.appendChild(sel); }
  }

  // Observe additions to the topology canvas and attach the select
  const canvas = document.getElementById('topoCanvas');
  if(canvas){
    const observer = new MutationObserver(muts => {
      muts.forEach(m => {
        m.addedNodes.forEach(n=>{
          if(n.nodeType===1 && n.classList.contains('node')) attachOfficeSelect(n);
        });
      });
    });
    observer.observe(canvas, {childList:true});
    // attach to existing nodes if any
    $$('.node').forEach(attachOfficeSelect);
  }

  // Ensure the assign table has an Office column (purely additive formatting step)
  (function ensureAssignHeader(){
    const ths = $$('#assignTbl thead th');
    if(!ths.length) return;
    const labels = ths.map(th=>th.textContent.trim());
    if(labels[3] !== 'Office'){
      // Insert "Office" column after Type
      ths[2].insertAdjacentHTML('afterend','<th>Office</th>');
      // Shift existing body rows
      $$('#assignTbl tbody tr').forEach(tr=>{
        const tds = tr.children;
        if(tds.length>=7){
          tds[2].insertAdjacentHTML('afterend','<td>Unassigned</td>');
        }
      });
    }
  })();

  // Refresh the Office column values based on node selects
  function refreshAssignOfficeColumn(){
    const rows = $$('#assignTbl tbody tr');
    rows.forEach((tr, idx)=>{
      const name = tr.children[1]?.textContent?.trim();
      if(!name) return;
      // Find node by its label text inside .node .tag (best-effort, non-invasive)
      const node = Array.from($$('.node .tag')).find(el=> el.textContent.trim()===name);
      const sel = node ? node.parentElement.querySelector('.officeSel') : null;
      const office = sel ? sel.value : 'Unassigned';
      // Ensure column 4 exists (index 3)
      if(tr.children.length>=8){
        tr.children[3].textContent = office;
      }
    });
  }

  // Read VLSM table to build pools per office
  function getVlsmPools(){
    const rows = $$('#vlsmTbl tbody tr');
    const pools = {}; // office -> array of {net,prefix,gw,first,last,ips[]}
    function ipToInt(ip){return ip.split('.').map(Number).reduce((a,o)=>(a<<8)+o,0)>>>0;}
    function intToIp(n){return [24,16,8,0].map(s=>(n>>>s)&255).join('.');}

    rows.forEach(r=>{
      const cells = Array.from(r.children).map(td=>td.textContent.trim());
      if(cells.length < 11) return;
      const office = cells[0]; // Office
      const prefixText = cells[2]; // "/xx"
      if(!prefixText || !prefixText.startsWith('/')) return;
      const prefix = Number(prefixText.slice(1));
      const net = cells[5], gw = cells[6], first = cells[7], last = cells[8];
      const firstInt = ipToInt(first), lastInt = ipToInt(last);
      const gwInt = gw && gw.includes('.') ? ipToInt(gw) : null;
      const ips = [];
      if(prefix===32){ ips.push(first); }
      else if(prefix===31){ ips.push(first, last); }
      else{
        for(let n=firstInt; n<=lastInt; n++){
          if(gwInt!==null && n===gwInt) continue;
          ips.push(intToIp(n));
        }
      }
      (pools[office] ||= []).push({office, prefix, net, gw, first, last, ips});
    });
    return pools;
  }

  function assignIPsByOffice(){
    refreshAssignOfficeColumn();
    const pools = getVlsmPools();
    if(Object.keys(pools).length===0) return;

    const rows = $$('#assignTbl tbody tr');
    rows.forEach(tr=>{
      // columns: #, Device, Type, Office, Subnet, Prefix, Gateway/Hint, Assigned IP
      if(tr.children.length < 8) return;
      const office = tr.children[3].textContent.trim();
      const subnetCell = tr.children[4], prefixCell = tr.children[5], gwCell = tr.children[6], ipCell = tr.children[7];

      function pull(officeName){
        const arr = pools[officeName] || [];
        for(const p of arr){
          const ip = p.ips.shift();
          if(ip) return {ip, pool:p};
        }
        return null;
      }

      let res = pull(office);
      if(!res){
        // fallback: any office
        for(const off of Object.keys(pools)){
          res = pull(off);
          if(res){ tr.children[3].textContent = off; break; }
        }
      }
      if(res){
        subnetCell.textContent = res.pool.net;
        prefixCell.textContent = '/' + res.pool.prefix;
        gwCell.textContent = res.pool.gw || res.pool.first;
        ipCell.textContent = res.ip;
      }else{
        subnetCell.textContent = '—';
        prefixCell.textContent = '—';
        gwCell.textContent = '—';
        ipCell.textContent = '(no more hosts)';
      }
    });
  }

  // Hook after Run VLSM (additive; does not replace existing handler)
  const runBtn = document.getElementById('runVLSM') || document.getElementById('runVlsm') || document.querySelector('[id*=runVlsm]');
  if(runBtn){
    // runBtn.addEventListener('click', ()=> setTimeout(assignIPsByOffice, 0)); // disabled: IP policy handled by assignIPsFromVLSM
  }

  // Keep Office choices fresh if LAN names change
  setInterval(()=>{
    const names = getOfficeNames();
    $$('.node .officeSel').forEach(sel=>{
      const val = sel.value;
      sel.innerHTML = ['Unassigned', ...names].map(n=>`<option value="${n}">${n}</option>`).join('');
      if(names.includes(val)) sel.value = val; else sel.value = 'Unassigned';
    });
  }, 1500);

})();
</script>

<script>
// === Patch: Default office selection for new devices (UI-only; no logic changes) ===
(function(){
  const $$ = (s)=>Array.from(document.querySelectorAll(s));
  const officeWrap = document.getElementById('officeDefaultWrap');
  let defaultOffice = 'Unassigned';

  function getOfficeNames(){
    const wrap = document.getElementById('lanBlocks'); if(!wrap) return [];
    return Array.from(wrap.querySelectorAll('.lanCard')).map((c,i)=>{
      const v = (c.querySelector('.lanName')?.value||'').trim();
      return v || `Office ${i+1}`;
    });
  }

  function refreshDefaultOfficeOptions(){
    const sel = document.getElementById('defaultOfficeSel');
    if(!sel) return;
    const names = getOfficeNames();
    const opts = ['Unassigned', ...names];
    const current = sel.value || defaultOffice;
    sel.innerHTML = opts.map(n=>`<option value="${n}">${n}</option>`).join('');
    if(opts.includes(current)) sel.value = current; else sel.value = 'Unassigned';
    defaultOffice = sel.value;
  }

  if(officeWrap){
    const sel = document.getElementById('defaultOfficeSel');
    if(sel){
      sel.addEventListener('change', ()=>{ defaultOffice = sel.value || 'Unassigned'; });
      // keep options fresh as offices are edited
      setInterval(refreshDefaultOfficeOptions, 1000);
      refreshDefaultOfficeOptions();
    }
  }

  // Hook into future node additions: when a node receives its per-node office <select>, set its default
  const canvas = document.getElementById('topoCanvas');
  if(canvas){
    const obs = new MutationObserver((muts)=>{
      muts.forEach(m=>{
        m.addedNodes.forEach(n=>{
          if(n.nodeType===1 && n.classList.contains('node')){
            const sel = n.querySelector('.officeSel');
            if(sel){
              // Apply current default office if available in list
              const names = Array.from(sel.options).map(o=>o.value);
              sel.value = names.includes(defaultOffice) ? defaultOffice : 'Unassigned';
              // ensure table reflects office
              const evt = new Event('change', {bubbles:true});
              sel.dispatchEvent(evt);
            }
          }
        });
      });
    });
    obs.observe(canvas, {childList:true});
  }
})();
</script>


<script>
// === Helper: add device directly to selected Office (no topology UI needed) ===
(function(){
  function ensureOfficeName(div, idx){
    const input = div.querySelector('.lanName');
    let name = (input && input.value.trim()) || `Office ${idx+1}`;
    if(input && !input.value.trim()){ input.value = name; }
    return name;
  }

  // Wait helper
  function waitFor(fn, timeout=800, interval=40){
    return new Promise((resolve,reject)=>{
      const start = performance.now();
      const t = setInterval(()=>{
        try{
          const v = fn();
          if(v){ clearInterval(t); resolve(v); }
          else if(performance.now() - start > timeout){ clearInterval(t); resolve(null); }
        }catch(e){ clearInterval(t); reject(e); }
      }, interval);
    });
  }

  window.addOfficeDevice = async function(div, idx, type){
    // 1) Create device via existing logic
    if (typeof addDevice === 'function'){ addDevice(type); } else { return; }

    // 2) Determine office name
    const officeName = ensureOfficeName(div, idx);

    // 3) Find the last created node
    const node = await waitFor(()=>{
      const nodes = Array.from(document.querySelectorAll('#topoCanvas .node'));
      return nodes.length ? nodes[nodes.length-1] : null;
    }, 1200, 50);

    // 4) Ensure node has an office selector (attachOfficeSelect observer should add it)
    let sel = node ? node.querySelector('.officeSel') : null;
    if(!sel){
      // Try to trigger the addon by forcing a small mutation
      if(node){ node.classList.add('pendingOffice'); node.classList.remove('pendingOffice'); }
      sel = await waitFor(()=> node && node.querySelector('.officeSel'), 1200, 50);
    }

    // 5) Set the office on the hidden select so all logic (counting/VLSM) sees it
    if(sel){
      // Refresh options (names may have changed)
      const names = Array.from(document.querySelectorAll('#lanBlocks .lanCard .lanName')).map((i,ix)=> (i.value||'').trim() || `Office ${ix+1}`);
      const opts = ['Unassigned', ...names];
      sel.innerHTML = opts.map(n=>`<option value="${n}">${n}</option>`).join('');
      sel.value = opts.includes(officeName) ? officeName : 'Unassigned';
      sel.dispatchEvent(new Event('change', {bubbles:true}));
    }

    // 6) Also sync Assign table row for instant feedback
    const rows = Array.from(document.querySelectorAll('#assignTbl tbody tr'));
    const last = rows[rows.length-1];
    if(last && last.children.length >= 8){
      last.children[3].textContent = sel ? sel.value : officeName;
    }

    // 7) Re-run IP assignment if VLSM already exists
    if (typeof assignIPsFromVLSM === 'function'){ assignIPsFromVLSM(); }
  };
})();
</script>



<script>
(function(){
  const sel = document.getElementById('vlsmBase');
  if(!sel) return;
  const keep = sel.value;
  const opts = ['auto', ...Array.from({length:23}, (_,i)=>8+i)]; // /8.. /30
  sel.innerHTML = opts.map(v => v==='auto' 
      ? '<option value="auto">Auto (by class)</option>' 
      : `<option value="${v}">/${v}</option>`).join('');  
  if(keep) sel.value = keep;
  if(!sel.value) sel.value = 'auto';
})();
</script>


<!-- Populate Base block dropdown dynamically: Auto + /8.. /30 -->
<script>
(function(){
  const sel = document.getElementById('vlsmBase');
  if(!sel) return;
  const keep = sel.value;
  const opts = ['auto', ...Array.from({length:23}, (_,i)=>8+i)];
  sel.innerHTML = opts.map(v => v==='auto' ? '<option value="auto">Auto (by class)</option>'
                                          : `<option value="${v}">/${v}</option>`).join('');
  if(keep) sel.value = keep; if(!sel.value) sel.value = 'auto';
})();
</script>


<script>
(function(){
  const btn = document.getElementById('howManual');
  const modal = document.getElementById('manualModal');
  const header = document.getElementById('manualHeader');
  const body = document.getElementById('manualBody');
  const backdrop = document.getElementById('manualBackdrop');
  const closeBtn = document.getElementById('manualClose');
  const closeBtn2 = document.getElementById('manualClose2');
  if(!btn || !modal || !backdrop || !header) return;

  // ---- open / close ----
  function openModal(){
    backdrop.style.display = 'block';
    modal.style.display = 'block';
    // center once per open (keeps last size)
    if(!modal.dataset._sized){
      const vw = Math.max(document.documentElement.clientWidth, window.innerWidth||0);
      const vh = Math.max(document.documentElement.clientHeight, window.innerHeight||0);
      const w = Math.min(960, Math.max(380, Math.floor(vw*0.86)));
      const h = Math.min(Math.floor(vh*0.86), Math.max(280, Math.floor(vh*0.72)));
      modal.style.width = w + 'px';
      modal.style.height = h + 'px';
      modal.dataset._sized = '1';
    }
    modal.style.left = '50%';
    modal.style.top = '50%';
    modal.style.transform = 'translate(-50%,-50%)';
    document.body.style.overflow = 'hidden';
    // focus scroll container
    body && body.focus();
  }
  function closeModal(){
    backdrop.style.display = 'none';
    modal.style.display = 'none';
    document.body.style.overflow = '';
  }

  btn.addEventListener('click', openModal);
  backdrop.addEventListener('click', closeModal);
  if(closeBtn) closeBtn.addEventListener('click', closeModal);
  if(closeBtn2) closeBtn2.addEventListener('click', closeModal);
  // ---- drag by header ----
  let dragging=false, sx=0, sy=0, startLeft=0, startTop=0;
  function pxToNum(v){ return Number(String(v).replace('px',''))||0; }
  header.addEventListener('pointerdown', (e)=>{
    if(e.button!==0) return;
    dragging=true;
    header.setPointerCapture(e.pointerId);
    const rect = modal.getBoundingClientRect();
    // convert current translate(-50%,-50%) to absolute left/top
    const curLeft = rect.left, curTop = rect.top;
    startLeft = curLeft; startTop = curTop;
    sx = e.clientX; sy = e.clientY;
    // switch to absolute left/top (remove transform) for dragging
    modal.style.transform = 'none';
  });
  header.addEventListener('pointermove', (e)=>{
    if(!dragging) return;
    const dx = e.clientX - sx, dy = e.clientY - sy;
    const vw = Math.max(document.documentElement.clientWidth, window.innerWidth||0);
    const vh = Math.max(document.documentElement.clientHeight, window.innerHeight||0);
    const rect = modal.getBoundingClientRect();
    let nx = startLeft + dx;
    let ny = startTop + dy;
    // clamp to viewport
    nx = Math.max(0, Math.min(nx, vw - rect.width));
    ny = Math.max(0, Math.min(ny, vh - rect.height));
    modal.style.left = nx + 'px';
    modal.style.top  = ny + 'px';
  });
  function endDrag(e){
    if(!dragging) return;
    dragging=false;
    try{ header.releasePointerCapture(e.pointerId); }catch(_){}
  }
  header.addEventListener('pointerup', endDrag);
  header.addEventListener('pointercancel', endDrag);

  // keep modal inside viewport on window resize
  window.addEventListener('resize', ()=>{
    if(modal.style.display!=='block') return;
    const vw = Math.max(document.documentElement.clientWidth, window.innerWidth||0);
    const vh = Math.max(document.documentElement.clientHeight, window.innerHeight||0);
    const rect = modal.getBoundingClientRect();
    let nx = rect.left, ny = rect.top;
    nx = Math.max(0, Math.min(nx, vw - rect.width));
    ny = Math.max(0, Math.min(ny, vh - rect.height));
    modal.style.left = nx + 'px';
    modal.style.top  = ny + 'px';
  });
})();
</script>


<script>
(function(){
  var btn = document.getElementById('howManual');
  var modal = document.getElementById('manualModal');
  var backdrop = document.getElementById('manualBackdrop');
  var c1 = document.getElementById('manualClose');
  var c2 = document.getElementById('manualClose2');
  if(!btn || !modal || !backdrop) return;

  function lockScroll(on){
    var de = document.documentElement;
    if(on){
      document.body.style.overflow = 'hidden';
      de.style.overflow = 'hidden';
    }else{
      document.body.style.overflow = '';
      de.style.overflow = '';
    }
  }
  function openModal(){
    backdrop.style.display = 'block';
    modal.style.display = 'block';
    lockScroll(true);
  }
  function closeModal(){
    backdrop.style.display = 'none';
    modal.style.display = 'none';
    lockScroll(false);
  }

  // Wire up (idempotent)
  if(!btn._ip_easy_bound){
    btn.addEventListener('click', openModal);
    backdrop.addEventListener('click', closeModal);
    if(c1) c1.addEventListener('click', closeModal);
    if(c2) c2.addEventListener('click', closeModal);
    btn._ip_easy_bound = true;
  }
})();
</script>

<script>
// === IP‑Easy manual modal: single-scroll + close button binding ===
(function(){
  if (window._ipe_manual_bound) return; // idempotent
  window._ipe_manual_bound = true;
  var btn = document.getElementById('howManual');
  var modal = document.getElementById('manualModal');
  var backdrop = document.getElementById('manualBackdrop');
  var c1 = document.getElementById('manualClose');
  var c2 = document.getElementById('manualClose2');
  if(!btn || !modal || !backdrop) return;

  function lockScroll(on){
    var de = document.documentElement;
    if(on){ document.body.style.overflow='hidden'; de.style.overflow='hidden'; }
    else  { document.body.style.overflow='';       de.style.overflow=''; }
  }
  function openManual(){
    backdrop.style.display='block';
    modal.style.display='block';
    lockScroll(true);
  }
  function closeManual(){
    backdrop.style.display='none';
    modal.style.display='none';
    lockScroll(false);
  }

  btn.addEventListener('click', openManual);
  backdrop.addEventListener('click', closeManual);
  if(c1) c1.addEventListener('click', closeManual);
  if(c2) c2.addEventListener('click', closeManual);
})();
</script>


<script>
(function(){
  if (window._ipe_close_bind) return;
  window._ipe_close_bind = true;
  var modal = document.getElementById('manualModal');
  var backdrop = document.getElementById('manualBackdrop');
  var c1 = document.getElementById('manualClose');
  function lockScroll(on){
    var de = document.documentElement;
    if(on){ document.body.style.overflow='hidden'; de.style.overflow='hidden'; }
    else  { document.body.style.overflow='';       de.style.overflow=''; }
  }
  function closeManual(){
    if(backdrop) backdrop.style.display='none';
    if(modal) modal.style.display='none';
    lockScroll(false);
  }
  if(c1) c1.addEventListener('click', function(e){ e.preventDefault(); closeManual(); });
  // also close on backdrop click (kept as-is)
  if(backdrop) backdrop.addEventListener('click', closeManual);
})();
</script>


<script>
(function(){
  if (window._ipe_esc_bound) return;
  window._ipe_esc_bound = true;
  document.addEventListener('keydown', function(e){
    if(e.key !== 'Escape') return;
    var modal = document.getElementById('manualModal');
    if(!modal || modal.style.display !== 'block') return;
    var backdrop = document.getElementById('manualBackdrop');
    if(backdrop) backdrop.style.display = 'none';
    modal.style.display = 'none';
    // restore page scroll
    document.body.style.overflow = '';
    document.documentElement.style.overflow = '';
  });
})();
</script>


<script>
(function(){
  const btn = document.getElementById('p2pHelpBtn');
  const modal = document.getElementById('p2pHelpModal');
  const backdrop = document.getElementById('p2pHelpBackdrop');
  const closeBtn = document.getElementById('p2pHelpClose');

  if (!btn || !modal || !backdrop || !closeBtn) return;

  function openModal(){
    modal.style.display = 'block';
    backdrop.style.display = 'block';
    modal.focus();
  }
  function closeModal(){
    modal.style.display = 'none';
    backdrop.style.display = 'none';
  }

  btn.addEventListener('click', openModal);
  closeBtn.addEventListener('click', closeModal);
  backdrop.addEventListener('click', closeModal);

  window.addEventListener('keydown', function(e){
    if (e.key === 'Escape'){
      if (modal.style.display === 'block'){
        e.preventDefault();
        closeModal();
      }
    }
  });
})();
</script>

</body>
</html>
